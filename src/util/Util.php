<?php

namespace hati\util;

use hati\Hati;

/**
 * Util class is a helper class which has many helpful methods that can easily deal with
 * session, cookie and other aspect of a project. This class is under continuous improvement
 * as we discover many helper simple functions over time.
 */

class Util {

	/** Alternator index tracker */
	private static array $altIndex = [];

	/**
	 * Returns alternate values in a cyclical manner. It keeps track of an internal index for
	 * getting the item from the variable arguments. If no values are provided or if an empty
	 * array is passed, it resets the internal index for the given name and returns an empty string.
	 *
	 * @param string $name The name required to track the internal alternator index count
	 * @param mixed ...$values (as many parameters as needed)
	 */
	public static function alternate(string $name, mixed ...$values): mixed {
		if (!isset(self::$altIndex[$name]))
			self::$altIndex[$name] = 0;

		$i = self::$altIndex[$name];

		$option = Arr::varargsAsArray($values);
		if (count($option) === 0) {
			self::$altIndex[$name] = 0;
			return '';
		}

		$key = ($i++ % count($option));
		self::$altIndex[$name] = $i;

		return $option[$key];
	}

	/**
	 * PHP can run in both server & CLI. Using this, the execution environment
	 * can be detected.
	 *
	 * @return bool true if the environment is CLI, false otherwise
	 * **/
	public static function isCLI(): bool {
		if (in_array(PHP_SAPI, ['cli', 'phpdbg'], true)) {
			return true;
		}

		// PHP_SAPI could be 'cgi-fcgi', 'fpm-fcgi'.
		return !isset($_SERVER['REMOTE_ADDR']) && !isset($_SERVER['REQUEST_METHOD']);
	}

	/**
	 * Using this method the execution environment can be extracted.
	 * @return string Returns 'cli' if it is running CLI, 'server' if running in Apache/CGI
	 * **/
	public static function getExecEnv(): string {
		return self::isCLI() ? 'cli' : 'server';
	}

	/**
	 * Figures out whether a directory is empty or not.
	 *
	 * @param string $dirPath The directory path
	 * @return bool True if the directory is empty, false otherwise
	 **/
	public static function isDirEmpty(string $dirPath): bool {
		return count(glob($dirPath . '/*')) === 0;
	}

	/**
	 * A random token can be generated using this method. Default length
	 * of the token is 11. It uses shuffling of time value after md5
	 * encryption. However, it doesn't guarantee the uniqueness of the token.
	 * In order to get a unique id use {@link uniqueId} instead.
	 *
	 * @param int $len The length of the token.
	 * @return string A randomly generated token.
	 */
	public static function randToken(int $len = 11): string {
		return substr(str_shuffle(md5(time())),0, $len);
	}

	/**
	 * A unique string using php uniqid can be generated by this method.
	 * It uses more entropy to generate more random and unique string/id.
	 *
	 * @param string $prefix Any arbitrary string to be prefixed.
	 *
	 * @return string A unique string.
	 * */
	public static function uniqueId(string $prefix = ''): string {
		return uniqid($prefix, true);
	}

	/**
	 * This function can return the server root address. If the hati is inside
	 * any folder then it also includes that as part of the host address.
	 *
	 * @param bool $secure When set to true, the host url is returned in HTTPS
	 *
	 * @return String the server address including folder if Hati has one defined
	 * in HatiConfig file.
	 * */
	public static function host(bool $secure = true): string {
		$root = Hati::projectRoot();

		if (empty($_SERVER['HTTP_HOST'])) {
			return $root;
		}

		$host = $_SERVER['HTTP_HOST'];
		if ($host == 'localhost') {
			$folder = explode(DIRECTORY_SEPARATOR, rtrim($root, DIRECTORY_SEPARATOR));
			$folder = $folder[count($folder) - 1];
			$host = 'localhost/' . $folder;
		}

		$protocol = $secure ? 'https' : 'http';
		return sprintf("$protocol://%s/", $host);
	}

}